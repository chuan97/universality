import numpy as np
from scipy.linalg import eigh

def transition_matrix(H, Hext):
    vals, vects = eigh(H)
    m = np.abs(np.conj(np.transpose(vects)) @ Hext @ vects) 
    return m, vals

def select_transitions(m, energies):
    """
    given a transition matrix 'm' and the 'energies'
    of the different states, it computes which transitions are feasible. It requires that a given transition
    is smaller than the smallest energy difference between the
    allowed transitions.
    """
    m_trans_energy = np.zeros(shape = m.shape) 
    for idx, val in np.ndenumerate(m):
        m_trans_energy[idx] = np.abs(energies[idx[1]] - energies[idx[0]])
    
    m_min_dif = np.zeros(shape = m_trans_energy.shape) 
    for idx1, val1 in np.ndenumerate(m_trans_energy):
        difs = []
        for idx2, val2 in np.ndenumerate(m_trans_energy):
            if  idx1[1] > idx1[0] and idx2 != idx1 and idx2 != tuple(reversed(idx1)) and val1 > 0 and val2 > 0:
                difs.append(np.abs(val2 - val1))
                
        if difs != []:
            m_min_dif[idx1] = np.amin(np.array(difs))
            m_min_dif[tuple(reversed(idx1))] = np.amin(np.array(difs))
            
    m_trans = np.zeros(shape = m.shape)
    degenerates = []
    
    for idx, val in np.ndenumerate(m): 
        if m_min_dif[idx] < val and idx[0] != idx[1]: 
            degenerates.append(idx)
            
        m_trans[idx] = (m_min_dif[idx] > val) * val
    
    return m_trans, degenerates

def effective_energy(a, b):
    """
    given the energies of two transitions 'a' and 'b' it computes the energie of the transition resulting from
    the concatenation of the input transitions. It only deals with energies, it does not check whether or not
    the indices of the transitions match. For instance 0->1 + 1->2 = 0->2 while 0->1 + 2->3 does not make sense.
    """
    if a and b:
        return 1 / (1 / a + 1 / b)
    else:
        return 0.0
    
def optimize_transitions(m, order = 2):
    order = max(order, 1) # if order smaller that 1 make it 1
    
    m_alt = np.copy(m)
    for n in range(2, order + 1): # after one iteration we cover all second order processes, two iterations -> third order processes and so on
        for idx, val in np.ndenumerate(m): # iterate over transition matrix
            if idx[0] != idx[1] and val: # if a non diagonal element is filled it checks if it can be generated by compounding faster transitions
                candidates = [val] # list of candidate effective energies, val or remaining as originally is always a candidate
                for i in range(m.shape[1]): # iterate over all middle indexes of the sum 
                    ener = effective_energy(m[idx[0], i], m[i, idx[1]]) 
                    candidates.append(ener) # accept candidate 
                
                m_alt[idx] = np.amax(np.array(candidates)) # save best candidate
        
        m = np.copy(m_alt)
        
    return m
    
def fill_connections(m, order = 2):
    """
    given a transition matrix 'm' and an 'order', it fills the vacant entries of the matrix if
    the corresponding transition can be generated by compounding two previously existing transitions.
    The original transitions are considered of order 1, those obtained by compounding two first order transitions
    are considered of order 2, and so on. The process is iterated untill all allowed transitions of 
    order 'order' are filled.
    """
    order = max(order, 1) # if order smaller that 1 make it 1
    
    m_alt = np.copy(optimize_transitions(m, order = order))
    for n in range(2, order + 1): # after one iteration we cover all second order processes, two iterations -> third order processes and so on
        for idx, val in np.ndenumerate(m): # iterate over transition matrix
            if idx[0] != idx[1] and not val: # if a non diagonal element is vacant it attempts to fill it
                candidates = [0.0] # list of candidate effective energies, 0.0 or remaining vacant is always a candidate
                for i in range(m.shape[1]): # iterate over all middle indexes of the sum 
                    ener = effective_energy(m[idx[0], i], m[i, idx[1]]) 
                    candidates.append(ener) # accept candidate 
                
                m_alt[idx] = np.amax(np.array(candidates)) # save best candidate
        
        m = np.copy(optimize_transitions(m_alt, order = order))
        
    return m

def apply_cutoff(m, th):
    m_purged = np.zeros(shape = m.shape)
    
    for idx, val in np.ndenumerate(m):
        if val >= th:
            m_purged[idx] = val
            
    return m_purged

def universality_measure(m):
    min_t = np.amax(m)
 
    for idx, val in np.ndenumerate(m):
        if idx[0] != idx[1]:
            min_t = min(val, min_t)
            
    return min_t
